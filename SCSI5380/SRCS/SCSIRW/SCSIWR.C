/*****************************************************************************************************************************************************************************************************			SCSIWR Test Code 						******************************************************************************************************************************************************************************************************/#include <stdio.h>#include <sane.h>	OSErr result;#define SCSIBase	0x0C00	/* Output Data Register with DACK */#define SCSIGlobals	0x0C0C	/* Current SCSI Data with DACK 	*/#define dackWr	0x0201	/* Output Data Register with DACK	*/#define dackRd	0x0260	/* Current SCSI Data with DACK	*/#define sODR	0x0001	/* Output Data Register 	*/#define sWrICR	0x0011	/* Initiator Command Register	*/#define sWrMR2	0x0021	/* Mode Register 2	*/#define sWrTCR	0x0031	/* Target Command Register	*/#define sSER	0x0041	/* Select Enable Register	*/#define sDMAtx	0x0051	/* Start DMA Send	*/#define sTDMArx	0x0061	/* Start DMA Target Receive	*/#define sIDMArx	0x0071	/* Start DMA Intiator Receive 	*/#define sCDR	0x0000	/* Current SCSI Data 	*/#define sRdICR	0x0010	/* Initiator Command Register	*/#define sRdMR2	0x0020	/* Mode Register 2	*/#define sRdTCR	0x0030	/* Target Command Register 	*/#define sCSR	0x0040	/* Current SCSI Bus Status	*/#define sBSR	0x0050	/* Bus and Status Resgister	*/#define sIDR	0x0060	/* Input Data Register 	*/#define sRESET	0x0070	/* Reset Parity/Interrupt	*/main(){	EventRecord event;  printf("SCSI test in Progress Click mouse to continue.\n\n");  printf("This program requires 'Macsbug' to be installed.\n\n");  while (! GetNextEvent(mDownMask + keyDownMask, &event)) {};  result = SCSIReset();  TestResult();       printf("Click mouse to continue.\nUse 's' to step in the debugger.\n");  while (! GetNextEvent(mDownMask + keyDownMask, &event)) {};  asm {    Debugger;   /*    Invoke Macsbug debugger    */    MOVEA.L    (A7)+,A0                                    LINK       A6,#0xFFF8                                   MOVEM.L    D2-D7/A2-A4,-(A7)                           MOVEA.L    SCSIBase,A3	; SCSIBase    MOVEA.L    SCSIGlobals,A4	; SCSIGlobals     LEA        sWrICR(A3),A0                                              ; Set A0 to point to the Initiator Command                   ; Register.            ; 1) Set the BSY line to active low.  This line is set by accessing     ; The Initiator Command Register (HA 1 of the 5380 chip).  The     ; required bit setting is the 4th bit or the BSY bit.     ; The Initiator Command Register is also referred to as the ICR.     MOVE.B     #0x08,(A0)                                        	;  This move pulls the BSY line active low.         ; 2); Once the BSY bit has been set the Target Bit in the Mode     ; Register must be pulled low.  This can be accomplished by    ; the following code:         LEA        sWrMR2(A3),A0                                 	; Set A0 to point to the Mode Register 2.      MOVE.B     #0x40,(A0)                                                  ;  This move pulls the TARG bit active low.         ; 3)  Now the ICR which was used in step 1 above is again called and    ; the DBUS bit (bit zero) must be set to allow us to put data    ; out on the SCSI bus.  So we must reset our Address in     ; register A0.         LEA        sWrICR(A3),A0                                               ; Set A0 to point to the Initiator Command                   ; Register.       MOVE.B     #0x01,(A0)                                                  ;  This move pulls the DBUS bit active low.                        ; 4) We should now be able to write data out to the SCSI bus at      ; 	will by directing our hex data stream to the Output Data	;	Register.         	LEA 	sODR(A3),A0                                               ; Set A0 to point to the Initiator Command                   ; Register.       MOVE.B     #0xAA,(A0)                   ;  This move pulls the ODR bits active low.	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)	MOVE.B	#0x55,(A0)	MOVE.B	#0xAA,(A0)               UNLK    A6    }  result = SCSIReset();  TestResult();}TestResult(){    switch(result)    {      case noErr:        printf("SCSI noErr result.\n\n");        break;      default:        break;    }}