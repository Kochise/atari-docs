/**************************************************************************************************************************************************************************************************				SCSIRd Test Code  						***************************************************************************************************************************************************************************************************/#include <stdio.h>#include <sane.h>	OSErr result;#define SCSIBase	0x0C00	/* Output Data Register with DACK	*/#define SCSIGlobals	0x0C0C 	/* Current SCSI Data with DACK	*/#define dackWr		0x0201	/* Output Data Register with DACK	*/#define dackRd		0x0260	/* Current SCSI Data with DACK	*/#define sODR		0x0001	/* Output Data Register	*/#define sWrICR		0x0011	/* Initiator Command Register	*/#define sWrMR2		0x0021	/* Mode Register 2 	*/#define sWrTCR		0x0031	/* Target Command Register 	*/#define sSER		0x0041	/* Select Enable Register 	*/#define sDMAtx		0x0051	/* Start DMA Send 	*/#define sTDMArx	0x0061  	/* Start DMA Target Receive	*/#define sIDMArx	0x0071  	/* Start DMA Intiator Receive 	*/#define sCDR		0x0000	/* Current SCSI Data 	*/#define sRdICR		0x0010	/* Initiator Command Register 	*/#define sRdMR2		0x0020	/* Mode Register 2 	*/#define sRdTCR		0x0030	/* Target Command Register 	*/#define sCSR		0x0040	/* Current SCSI Bus Status	*/#define sBSR		0x0050	/* Bus and Status Resgister	*/#define sIDR		0x0060	/* Input Data Register 	*/#define sRESET		0x0070	/* Reset Parity/Interrupt	*/main(){	EventRecord event;	printf("SCSI test in Progress Click mouse to continue.\n\n");	printf("This program requires 'Macsbug' to be installed.\n\n");	while (! GetNextEvent(mDownMask + keyDownMask, &event)) {};	result = SCSIReset();	TestResult();				 printf("Click mouse to continue.\nUse 's' to step in the debugger.\n"); while (! GetNextEvent(mDownMask + keyDownMask, &event)) {}; asm {  Debugger;   /*   Invoke Macsbug debugger  */	MOVEA.L    (A7)+,A0                                	LINK		A6,#0xFFF8	MOVEM.L	D2-D7/A2-A4,-(A7) 	MOVEA.L	SCSIBase,A3  		; SCSIBase	MOVEA.L	SCSIGlobals,A4		; SCSIGlobals	LEA		sCDR(A3),A0                                 	; Set A0 to point to the Current SCSI Data          ;	1) 	Once the address register, A0, contains the address of the      ;		Current SCSI Data Register, the data can be read straight           ;		off the SCSI data lines.  Its up to the peripheral to place      ;		the data on the lines.  Other sections of the SCSI protocol      ;		can be implemented to deterimine when the data is available      ;		for reading.          ;	2)  Run the compiled application through the first mouse click.     ;		Then, use the method presented in the article to set the     ;		breadboard.  The object is to imitate a peripheral placing      ;		data on the SCSI bus.  The user can also choose to set the     ;		data lines directly on the SCSI bus avoiding the 5380 chip,     ;		if desired.	MOVE.B	(A0),D0	;Moves the data from the SCSI bus into D0	MOVE.B	(A0),D0	;The last word (last 2 bytes) of D0 will	MOVE.B	(A0),D0	;change to reflect the values of D0-D7 on	MOVE.B	(A0),D0	;the SCSI lines.  Use Macsbug to step	MOVE.B	(A0),D0	;through the list of MOVE.B commands. 	MOVE.B	(A0),D0	;Changing the Bus data lines will cause	MOVE.B	(A0),D0	;the contents of D0 to change.  D0 is 	MOVE.B	(A0),D0	;visible in Macsbug.	MOVE.B	(A0),D0	 	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0	MOVE.B	(A0),D0			UNLK		A6		}	result = SCSIReset();	TestResult();}TestResult(){		switch(result)		{			case noErr:				printf("SCSI noErr result.\n\n");				break;			default:				break;		}}