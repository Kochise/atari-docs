#{{{}}}
############################################################
# @(#) Die Anleitung zum SCSI-Treiber
# @(#) Copyright (c) 1998 by
# @(#) Steffen Engel
############################################################


#Kopf
#{{{

!ifdest [stg]
  !begin_raw
@subject "Dokumentation/Utilities"
@options +zz
  !end_raw
!else
  !code [tos]
  !autoref [off]
!endif

!no_preamble [tex]

!ifdest [tex]
  !begin_raw
    \documentclass[10pt]{article}
    \usepackage{german,makeidx,a4}
    \usepackage[]{graphicx}
    \makeindex
    % Umsetzen des Grafikmakros auf das graphics-Paket
    \def\IncludeGemIMG#1#2#3#4{\leavevmode\includegraphics[bb=0 0 #1 #2, scale=1]{#4}}
  !end_raw
!endif

!docinfo [author] Steffen Engel
!docinfo [address] Wiesenstr. 2
!docinfo [address] D-38102 Braunschweig
!docinfo [address] Email: Steffen.Engel @ t-online.de
!docinfo [address] MausNet: Steffen Engel @ SZ2

!docinfo [title] Systemglobaler SCSI-Treiber
!docinfo [program] SCSI-Treiber
#!docinfo [programimage] Images/logo
!docinfo [version] Text-Release 1.10

#!rtf_propfont Dutch
#!rtf_monofont Typewriter

!html_frames_backcolor silver

!html_modern_backcolor silver

#!html_modern_layout
!html_frames_layout


# Die Silbenregeln
#!include hyphens.ui

!sloppy
#}}}



!begin_document

!maketitle
!tableofcontents


#****************************************************************************
#
# $Source: u:\usr\src\scsi\cbhd\doc\RCS\SCSIDRV.U,v $
#
# $Revision: 1.5 $
#
# $Author: Steffen_Engel $
#
# $Date: 1997/01/18 11:23:48 $
#
# $State: Exp $
#
#****************************************************************************
# History:
#
# Revision 1.3  1995/09/29  08:06:18  S_Engel
# Verhalten unter virtuellem RAM dokumentiert.
#
# Revision 1.2  1995/02/10  00:52:50  S_Engel
# Handlekonzept eingefÅhrt, Doku erweitert
#
# Revision 1.1  1995/02/05  10:40:00  S_Engel
# Initial revision
#
#****************************************************************************


!node Vorwort
#{{{
  Diese Dokumentation ist nicht kurz, sie ist aber wichtig. Ich empfehle, den 
  Text auszudrucken, da er dann wesentlich Åbersichtlicher ist.

  Wesentlich ist der Teil zum Absetzen von SCSI-Kommandos und zur Abfrage der 
  vorhandenen Busse. Der Teil zur Installation von Targetroutinen ist nur fÅr 
  spezielle FÑlle nîtig. Die dazugehîrigen Funktionen mÅssen vom Treiber auch 
  nicht bereitgestellt werden. Die Existenz der Strukturen und des Treibers 
  lassen also keine RÅckschlÅsse auf die Mîglichkeit zur Installation von 
  Target-Routinen oder Disconnect zu.

  Wer einen Treiber benutzen oder selbst schreiben mîchte, hier sind 
  besonders die Autoren von Festplattentreibern gefragt, sollte als erstes 
  die Funktionen zur Benutzung und Abfrage der SCSI-Schnittstellen beachten. 
  Eine eventuelle UnterstÅtzung der Target-Routinen kann spÑter folgen.

  Als Beispiele kann man sich die beiligenden Programme und Quelltexte 
  ansehen. Diese Beispiele und Quelltexte stellen einen Bestandteil dieser 
  Dokumentation dar, daher sollte man diese auch beachten.
  Weiterhin ist damit klar, daû eine Weitergabe dieses Textes ohne die 
  Quelltexte unvollstÑndig ist.
#}}}

!node Einleitung
#{{{
  FÅr den Atari fehlen seit jeher systemglobale SCSI-Routinen. Dummerweise 
  muû daher jeder, der SCSI-GerÑte programmieren will, eigene SCSI-Routinen 
  schreiben, was mit jedem neuen Rechner von vorne los geht.

  Desweiteren ist es sinnvoll, mit den echten SCSI-Ports (wie bei TT, Falcon 
  oder der Medusa) auch als Target auftreten zu kînnen.

  Dazu kommen alternative SCSI-Ports, wie sie durch Zusatzkarten in ST, TT 
  oder der Medusa eingesetzt werden.

  Besonders wichtig sind Emulatoren (z.B.MagiCMac, MagiC_PC, STonX) oder 
  alternative Rechner (Clones), an deren SCSI-Ports man ja nicht herankommt, 
  wenn man die Hardware nicht kennt.

  Daher dieser Entwurf zur Installation eines globalen SCSI-Handlers. 
  Potentiell kann der Handler bereits im Betriebssystem installiert werden, 
  womit Plattentreiber auch auf die alternativen SCSI-Ports zugreifen kînnen, 
  ohne Kenntnis von der Implementierung der Hardware zu haben.

  Daraus ergibt sich die folgende Vorgehensweise fÅr alle SCSI nutzenden 
  Programme:

  !begin_itemize
    !item Bei Existenz des SCSI-Cookies sollen die darin zur VerfÅgung 
        gestellten Funktionen verwendet werden.
    !item Existiert der Cookie nicht, sollten, soweit vorhanden, eigene Routinen 
        verwendet werden.

        Bei Programmen, die nur auf den hier verwendeten Routinen aufsetzen und 
        keine eigenen Routinen on board haben, muû dementsprechend mit einer 
        Fehlermeldung abgebrochen werden.
  !end_itemize

  Auch Plattentreiber sollten dies so machen, denn es kînnen SCSI-Treiber 
  resetfest oder im ROM eingebunden werden, die dann vom Plattentreiber 
  benutzt werden sollten.

  Sollte der Cookie nicht installiert sein, so ist es sinnvoll, wenn 
  Plattentreiber diesen installieren, um ihre eigenen Routinen global zur 
  VerfÅgung zu stellen.

  ErwÅnschter Leistungsumfang des SCSI-Treibers:
  !begin_itemize
    !item FÑhigkeit zu krummen Transferzahlen auf ACSI (Stichwort DMA-fifo-Loch) 
    !item Class 1 Komandos auf ACSI (per ALIA-Technik, Linked-Cmd oder 
    ICD-Technik)
    !item FRB-Transfers (ACSI) sind Aufgabe des Treibers
  !end_itemize
#}}}

!node Aufbau des Treibers
#{{{
Prinzipiell unterscheidet sich die Benutzung des SCSI-Treibers von 
''(!V)Åblichen(!v)'' SCSI-Treibern und Libraries darin, daû man nicht direkt 
auf ein GerÑt zugreift, indem man die GerÑte-ID (SCSI-Adresse) angibt. Das 
Absetzen von Kommandos erfolgt Åber ein handle, welches man sich zunÑchst 
holen muû. Der Sinn der Sache ist, daû bei Fehlermeldungen des GerÑtes eine 
Weitergabe der Fehlermeldungen an andere Programme erfolgen kann, die ein 
handle auf das betreffende GerÑt besitzen.

Weiterhin ist der SCSI-Treiber so aufgebaut, daû mehr als nur die simplen 18 
GerÑte des Atari benutzt werden kînnen (s. GerÑteids bei DMARead/DMAWrite 
bzw. XHDI).

Da die mîgliche Anzahl der SCSI-Busse unbekannt ist (zwar nicht auf einem 
normalen Atari, aber dennoch auf Clones oder Emulatoren), und die Anzahl der 
auf einem Bus mîglichen GerÑte (einige SCSI-Architekuren erlauben SCSI-Ids 
mit 64 Bit!) ist es notwendig, Funktionen zu implementieren, die eine 
Abfrage der Busse und der dort befindlichen GerÑte ermîglichen. Diese sind in 
etwa mit Fsfirst/Fsnext oder dopendir/dreaddir zu vergleichen.

Damit ergeben sich zwei Mîglichkeiten fÅr den Zugriff auf ein SCSI-GerÑt:

!begin_enumerate
  !item Die Bus-Nummer und die SCSI-Adresse eines GerÑtes sind bekannt (aus 
  gespeicherten Parametern der Applikation).

  In diesem Fall reicht es aus, mit CheckDev die Existenz des GerÑtes zu ÅberprÅfen und
  mit Open ein Handle fÅr das GerÑt zu holen und darÅber zuzugreifen.
# wegen ICD/... auf ACSI.

  !item Sind Busnummer und ID eines zu benutzenden GerÑtes nicht bekannt, 
  oder sollen z.B. alle vorhanden GerÑte eines Typs verwaltet werden 
  (Festplatten durch den Plattentreiber, CD-ROMS durch den CD-Treiber), so 
  kann man die Busse und auf den Bussen die vorhandenen GerÑte erfragen.

  Die Abfrage der Busse erfolgt mit der Funktion InquireSCSI, es werden alle 
  vorhandenen Busse gemeldet. Die Abfrage erfolgt dabei wie bei Fsfirst/next 
  mittels InquireSCSI(cInqFirst) und danach InquireSCSI(cInqNext) bis 
  keine weiteren Busse mehr gemeldet werden.

  FÅr jeden der Busse kann dann mit InquireBus(cInqFirst/Next) die Liste 
  der vorhandenen GerÑte abgefragt werden.

  Mit den erhaltenen IDs kann dann kontrolliert werden, ob das GerÑt fÅr das 
  Programm interessant ist.

  Will man beispielsweise alle CD-ROMs in einem CD-Treiber benutzen, so sieht 
  der Ablauf in etwa so aus:

!begin_verbatim
  ret = InquireSCSI(cInqFirst, &BusInfo);
  while (ret == 0)
  {
    ret = InquireBus(cInqFirst, BusInfo.Busno, &DevInfo);
    while (ret == 0)
    {
      handle = Open(BusInfo.BusNo, DevInfo.SCSIId, &MaxLen);
      if (0 == Inquiry(handle, InquiryData);
            && InquiryData.Device == CDROM)
      {
        /* GerÑt installieren */
        InstallCD(handle);
      }
      else
      {
        /* handle nicht mehr nîtig */
        Close(handle);
      }
      ret = InquireBus(cInqNext, &DevInfo);
    }
    ret = InquireSCSI(InquireNext, &BusInfo);
  }
!end_verbatim


!end_enumerate


#}}}


!node Treiberfunktionen

!subnode Strukturen
#{{{
!begin_verbatim
  XBRA      : SCSI

  Vektoren  : Falcon : MFP-Interrupt 7, Vektor 7
                       (normal VR $40 -> $11C)
              TT     : TT-MFP-Interrupt 15, Vektor 7
                       (normal VR $50 -> $17C)
!end_verbatim


  Aufbau des SCSI-Cookies:

  Name des Cookie: SCSI
  Wert des Cookie: Zeiger auf die Struktur tScsiCall
                   (Typen siehe scsidefs.h, SCSIDefs.d)
#}}}

!subnode Nomenklatur
#{{{
!begin_xlist [BOOLEAN:  ]
  !item [BYTE:] 8 Bit (unsigned char)
  !item [UWORD:] 16 Bit ganzzahlig positiv (unsigned word)
  !item [ULONG:] 32 Bit ganzzahlig positiv (unsigned long)
  !item [WORD:] 16 Bit ganzzahlig (word)
  !item [LONG:] 32 Bit ganzzahlig (long)
  !item [BOOLEAN:]
              WORD
              TRUE  : 1
              FALSE : 0
!end_xlist

  benutzte Register in den Routinen:
    D0-D2, A0-A1  (PureC-Konvention)

  ParameterÅbergabe:
    auf dem Stack (cdecl) ( NEIN!! nichts anderes!!! )
#}}}

!node Funktionen
!subtoc [stg,html,pch]

!subnode InquireSCSI
#{{{
!begin_verbatim
  LONG  cdecl (*InquireSCSI)  (WORD       what,
                               tBusInfo  *Info);
    #define cInqFirst  0
    #define cInqNext   1


  typedef struct
  {
    tPrivate Private;
     /* fÅr den Treiber bzw. reserviert */
    char  BusName[20];
     /* zB 'SCSI', 'ACSI', 'PAK-SCSI', nullterminiert */
    UWORD BusNo;
    UWORD BusNo;
     /* Nummer, unter der der Bus anzusprechen ist */
    UWORD Features;
    /* bis zu 16 Features, die der Bus kann, z.B.Arbit,
     * Full-SCSI (alle SCSI-Cmds im Gegensatz zu ACSI)
     * Target- oder Initiator-gesteuert, etc.
     * Ein SCSI-Handle ist auch ein Zeiger auf eine Kopie dieser
     * Information!
     */
        #define cArbit     0x01
            /* auf dem Bus wird arbitriert */
        #define cAllCmds   0x02
            /* hier kînnen alle SCSI-Cmds abgesetzt werden,
             * zB ist bei ACSI nur Class 0 garantierbar             */
        #define cTargCtrl  0x04
            /* Das Target steuert den Ablauf (so soll's sein!)      */
        #define cTarget    0x08
            /* auf diesem Bus kann man sich als Target installieren */
        #define cCanDisconnect 0x10
            /* Disconnect ist mîglich  */
        #define cScatterGather 0x20
            /* scatter gather bei virtuellem RAM mîglich */
    ULONG MaxLen;
    /* maximale TransferlÑnge auf diesem Bus (in Bytes)
     * entspricht z.B.bei ACSI der Grîûe des FRB
     * minimal 64kB (eine FRB-Grîûe)
     */
  }tBusInfo;
!end_verbatim


Nach vorhandenen Bussen suchen.
Man ruft, Ñhnlich zu Fsfirst/Fsnext, zunÑchst mit InqFirst in what auf, 
danach mit InqNext, bis ein negativer Wert auftritt.
Die Reihenfolge der Meldungen (erst Bus 0, dann 1 dann 2) ist _nicht_ 
gewÑhrleistet, es kann auch sein, daû erst Bus 3, dann Bus 2, dann 0, dann 1 
gemeldet wird.

Es sind maximal 32 Busse mîglich.

Man erhÑlt Informationen Åber den Bus in der Info-Struktur.

Ergebnis:

!begin_verbatim
  = 0   : Ok
  < 0 : Kein weiteres GerÑt
!end_verbatim

ACHTUNG: es muû natÅrlich immer der gleiche Record fÅr Info genommen werden, 
da darin von den Treibern protokolliert wird, welche GerÑte bereits gemeldet wurden.

Aufgabe: FÅr Konfigurationsdialoge oder auch selbsttÑtige Konfiguration nach 
den vorhandenen Bussen suchen.

Annahmen Åber die Art des Busses aufgrund seiner Busnummer sind (!U)nicht 
zulÑssig(!u)!

Es sind keine Annahmen Åber die Anzahl der GerÑte oder die maximale GerÑte-Id 
zulÑssig. Die vorhandenen GerÑte mÅssen mit InquireBus erfragt werden.

Beispiel: siehe SRCHDRV.C
#}}}

!subnode InquireBus
#{{{
!begin_verbatim
  LONG  cdecl (*InquireBus)   (WORD       what,
                               WORD       BusNo,
                               tDevInfo  *Dev);

  typedef struct
  {
    BYTE Private[32]; /* geht nur den Treiber fÅr diesen Bus was an */
    DLONG SCSIId;
  }tDevInfo;

!end_verbatim


Einen Bus nach vorhandenen GerÑten abfragen. Erster Aufruf mit cInqFirst,
danach mit cInqNext. Liefert 0, bis keine weiteren Ids mehr berichtet werden.
Auch hier muû natÅrlich immer die gleiche Struktur fÅr 'Dev' benutzt werden.

Ergebnis:
!begin_verbatim
  = 0 : Ok
  < 0 : keine weiteren GerÑte
!end_verbatim

Beispiel: siehe SRCHDRV.C
#}}}

!subnode Open
#{{{
!begin_verbatim
  LONG  cdecl (*Open)         (WORD         BusNo,
                               const DLONG *SCSIId,
                               ULONG       *MaxLen);
!end_verbatim

Ein Handle fÅr ein GerÑt holen.

SCSIId ist die SCSI-Id des GerÑtes, fÅr das das Handle geliefert werden soll.
Die Variable ist 64 Bit groû, um die Vorgaben von SCSI-3 erfÅllen zu kînnen. 
Bei den bisher zur VerfÅgung stehenden Treibern und Bussen werden nur die 
unteren 8 Bit (von SCSIId.lo) verwendet. Der Rest muû 0 sein. Es ist nicht 
zulÑssig, irgendwelche anderen Informationen in der SCSI-Id unterzubringen!

Ein SCSI-Handle ist ein Zeiger auf den Featurevektor fÅr dieses GerÑt
(siehe 'Features' in tBusInfo). 

Ergebnis
!begin_verbatim
  handle (Zeiger auf Featurevektor)
    In MaxLen ist angegeben, welche maximale TransferlÑnge mit einem
    Zugriff Åbertragen werden kann.

  Highbyte = 0xff : Fehler
    ENHNDL : keine Handles mehr frei
    EUNDEV : unbekanntes GerÑt auf diesen Bus/unbekannter Bus
    EACCDN : unerlaubtes GerÑt auf diesem Bus (z.B.eigene SCSI-Id bei
             Arbitrierung, falls der Treiber kein virtuelles GerÑt
             auf der ID emuliert)
!end_verbatim
#}}}

!subnode Close
#{{{
!begin_verbatim
  LONG  cdecl (*Close)        (tHandle    handle);
!end_verbatim


Handle wieder freigeben

Ergebnis:
!begin_verbatim
  = 0 : Ok
  < 0 : Fehler
EINVHDL : ungÅltiges Handle
!end_verbatim
#}}}

!subnode Error
#{{{
!begin_verbatim
  LONG  cdecl (*Error)        (tHandle    handle,
                               WORD       rwflag,
                               WORD       ErrNo);
        #define cErrRead   0
        #define cErrWrite  1
          #define cErrMediach  0
          #define cErrReset    1
!end_verbatim

Fehlerstatus auf dem GerÑt abfragen/setzen

Hiermit kann man fragen, welche Fehler auf dem GerÑt in letzter Zeit
aufgetreten sind.
Dies ist nîtig, da evtl. mehrere Programme mit diesem GerÑt arbeiten und 
damit derjenige, der den Status mit Request Sense ausliest, der einzige ist, 
der weiû, was passiert ist.
Daher muû jeder, der Request Sense auswertet, einen entsprechenden Fehler 
melden, damit dieser fÅr alle anderen Prozesse mit einem offenen Hande 
protokolliert wird.

Gemeldet werden muû alles, was einen Wechselstatus des GerÑtes ergibt, also 
Mediach und Reset. Diese Meldung muû von der Applikation abgesetzt werden, da 
nur sie das GerÑt logisch kennt, und sie so entscheiden muû, was ein 
Medienwechsel ist.

So kann z.B.ein Plattentreiber einen Mediachange mitbekommen, wenn bei 
einem Image-Backup das Medium gewechselt wurde.

rwflag = 0 fragt den Status ab (16 Bit Bitvektor) und lîscht ihn fÅr dieses 
handle. rwflag = 1 setzt das Bit ErrNo bei allen auf dieses GerÑt geîffneten 
handles bis auf dieses Handle selbst.

Ergebnis
!begin_verbatim
  rwflag=0: 16 Bit Fehlervektor. Bit 0 = 1: Mediachange, ...
  rwflag=1: 0=Kein Fehler
  Highbyte = $FF: Fehler
!end_verbatim

#}}}

!subnode In/Out
#{{{
Sendet ein SCSI-Kommando, In empfÑngt die kommenden Daten, Out sendet 
Daten.

Als Parameter wird ein Zeiger auf eine SCSI-Kommandostruktur Åbergeben, in der 
alle nîtigen Informationen Åber den gewÅnschten Zugriff enthalten sind.

Beachte: Parms ist kein const *, also kînnen die Inhalte des Parameterblockes 
vom Treiber benutzt und verÑndert werden.

Wenn auf diesem Handle noch ein mit Error() gesetzter Fehler ansteht,
liefert der Treiber sofort PENDINGERROR und fÅhrt keinen Transfer aus.

!begin_verbatim
  LONG  cdecl (*In)            (tpSCSICmd  Parms);
  LONG  cdecl (*Out)           (tpSCSICmd  Parms);

  typedef struct
  {
    tHandle Handle;            /* Handle fÅr Bus und GerÑt          */
    BYTE  *Cmd;                /* Zeiger auf CmdBlock               */
    UWORD CmdLen;              /* LÑnge des Cmd-Block               */ 
    void  *Buffer;             /* Datenpuffer                       */
    ULONG TransferLen;         /* öbertragungslÑnge                 */
    BYTE  *SenseBuffer;        /* Puffer fÅr ReqSense (18 Bytes)    */
    ULONG Timeout;             /* Timeout in 1/200 sec              */
    UWORD Flags;               /* Bitvektor fÅr AblaufwÅnsche       */
      #define Disconnect 0x10  /* versuche disconnect               */

  }tSCSICmd;
  typedef tSCSICmd *tpSCSICmd;
!end_verbatim

!begin_xlist [SenseBuffer: ]
 !item [Handle:]
        Das Handle des angesprochenen GerÑtes
 !item [Cmd:]
        Zeiger auf den zu Åbertragenden Kommandoblock. Der Inhalt des 
        Blockes wird nicht vom Treiber verÑndert, der Zeiger jedoch kann 
        verÑndert werden.
 !item [CmdLen:]
        LÑnge des Kommandoblockes
        (!N)Die KommandolÑnge ist eigentlich fÅr einen SCSI-Treiber nicht nîtig. 
        Da ACSI jedoch nicht targetgesteuert ablaufen kann, einige 
        Plattentreiber dieses Feature auch auf den echten SCSI-Ports nicht 
        verwenden und zukÅnftige GerÑtetreiber fÅr Clones (Mac/Gemulator/STOnX) 
        evtl. diesen Wert ebenfalls benîtigen, muû er immer angegeben 
        werden.(!n)
  !item [Buffer:] Zeiger auf den Transferpuffer. Der Inhalt des Puffers wird 
  bei In logischerweise verÑndert. Bei Out bleibt der Inhalt des Puffers 
  unverÑndert.
  !item [TransferLen:] Anzahl der zu Åbertragenden Bytes.
  !item [SenseBuffer:] Puffer fÅr Request Sense Daten.

        Wird automatisch gefÅllt, wenn das GerÑt Check Condition meldet. Die 
        Applikation setzt bei Bedarf Åber die Funktion Error() Fehlermeldungen 
        (z. B. Medienwechsel) fÅr andere Handles ab.

        Dabei wird vom SCSI-Treiber nicht selbststÑndig eine Fehlermeldung 
        abgesetzt (Åber die Funktion Error), dies muû die Applikation 
        entscheiden und ausfÅhren.

        Ist SenseBuffer ein Nullpointer fÅhrt der SCSI-Treiber kein Request 
        Sense durch. (erst erlaubt ab SCSI-Treiber 1.01), In diesem Fall ist 
        die Applikation fÅr die komplette Fehlerbehandlung verantwortlich.

        Weiterhin ist dabei zu beachten, daû nicht garantiert werden kann, 
        daû der Sensecode nicht von einer anderen Applikation abgeholt 
        worden sein kann. Dies ist zwar sehr unwahrscheinlich, aber aufgrund 
        der Mîglichkeiten zu Disconnect und Queing durchaus denkbar.

 !item [Timeout:] Maximale Wartezeit fÅr die AusfÅhrung des Kommandos in 
 1/200 sec.

 !item [Flags:] Bitvektor mit Zusatzinformationen/aufforderungen
 !end_xlist


Bemerkung: die LÑnge des Kommandoblockes ist eigentlich nur fÅr ACSI nîtig, oder 
fÅr Treiber, die nicht vom Target gesteuert werden. Daher muû sie immer korrekt 
Åbergeben werden

(!N) Laut SCSI-Norm steuert das angesprochene Target die Bus-Phasen. Das heiût, 
das Target fordert solange Kommando-Bytes an, bis es die Anzahl der zu dem 
Kommando gehîrenden Bytes erhalten hat.

Daher ist es fÅr die SCSI-Routinen nicht nîtig, zu wissen, wie lang das Kommando 
ist.

Bei ACSI kann die Busphase nicht abgefragt werden, daher muû die KommandolÑnge 
immer genannt werden.
(!n)

Ergebnis:
!begin_verbatim
  NOSCSIERROR     0L /* Kein Fehler                               */
  SELECTERROR    -1L /* Fehler beim Selektieren                   */
  STATUSERROR    -2L /* Default-Fehler                            */
  PHASEERROR     -3L /* ungÅltige Phase                           */
  BSYERROR       -4L /* BSY verloren                              */
  BUSERROR       -5L /* Busfehler bei DMA-öbertragung             */
  TRANSERROR     -6L /* Fehler beim DMA-Transfer (nichts Åbertragen)*/
  FREEERROR      -7L /* Bus wird nicht mehr freigegeben           */
  TIMEOUTERROR   -8L /* Timeout                                   */
  DATATOOLONG    -9L /* Daten fÅr ACSI-Softtransfer zu lang       */
  LINKERROR     -10L /* Fehler beim Senden des Linked-Command (ACSI)*/
  TIMEOUTARBIT  -11L /* Timeout bei der Arbitrierung              */
  PENDINGERROR  -12L /* auf diesem handle ist ein Fehler vermerkt */
  PARITIYERROR  -13L /* Transfer verursachte Parity-Fehler        */

!end_verbatim

  Wert grîûer Null: Statusbyte des SCSI-GerÑtes, bei Status 2 (Check Condition) 
  befinden sich die RequestSense-Daten im Sensebuffer.


BEISPIEL:

Aufruf von Inquiry

!begin_verbatim
WORD Inquiry(tHandle handle, char *inqdata)
{
  tScsiCmd ScsiCmd;
  BYTE CmdBlock[6]={0x12,0,0,0,36,0};   /* Kommand 18, 36 Bytes */
  BYTE ReqBuff[18];

  ScsiCmd.Handle      = handle;       /* GerÑtehandle */
  ScsiCmd.Cmd         = CmdBlock;     /* das Kommando */
  ScsiCmd.CmdLen      = 6;            /* 6-Byte-Kommando */
  ScsiCmd.Buffer      = inqdata;      /* Datenpuffer */
  ScsiCmd.TransLen    = 36;           /* 36 Bytes erwartet */
  ScsiCmd.SenseBuffer = ReqBuff;      /* bei Fehlern dorthin */
  ScsiCmd.Timeout     = 1000;         /* 5 sec */
  ScsiCmd.Flags       = 0;            /* keine Besonderheiten */
 
  return (ScsiCall->In((tpScsiCmd)&ScsiCmd));
}
!end_verbatim

ACHTUNG:
  Bei virtuellem RAM ist selbst auf den Transfer Åber ST-RAM zu achten (s. 
  Abschnitt VIRTUELLES RAM)
#}}}


ACHTUNG:
!begin_verbatim
Bei virtuellem RAM ist selbst auf den Transfer Åber ST-RAM zu
achten (s. Abschnitt VIRTUELLES RAM)
!end_verbatim
#}}}

!subnode CheckDev
#{{{
!begin_verbatim
  LONG  cdecl (*CheckDev)     (WORD         BusNo,
                               const DLONG *SCSIId,
                               char        *Name,
                               UWORD       *Features);
!end_verbatim


Wie InquireSCSI, nur daû explizit nach einem bestimmten Bus und einer 
bestimmten SCSI-ID gefragt wird.

Als Antwort erhÑlt man den Namen des Busses, sowie die Informationen, was mit 
dem genannten GerÑt mîglich ist.

Name ist dabei char[20]

Ergebnis:
!begin_verbatim
  = 0         : Ok
  < 0         : Fehler
   -2 EDRIVNR : Informationen konnten nicht ermittelt werden (zB
                Kontrolle auf ICD-FÑhigkeit)
  -15 EUNDEV  : Die Busnummer oder die GerÑtenummer wird nicht
                verwaltet
  -36 EACCDN  : Zugriff nicht mîglich (z.B.eigene SCSI-Id auf einem 
                arbitrierenden Bus)
!end_verbatim

Dies ist fÅr zwei Dinge sinnvoll:

!begin_itemize
!item Ein Programm lÑdt eine Parameterdatei und kann hiermit kontrollieren, ob
  !begin_itemize
    !item der Bus existiert
    !item der Busname verÑndert ist (bei alternativen Bussen kînnen
      Unterschiede vorhanden sein)
    !item das GerÑt ansprechbar ist
  !end_itemize

!item FÅr alternative Hostadapter kontrolliert der Treiber, ob er speziell 
 dieses GerÑt anders ansprechen kann, als auf dem Bus Åblich (z.B.ICD: voller 
 Kommandosatz auf ACSI auf _diesem_ GerÑt)
!end_itemize
#}}}

!subnode RescanBus
#{{{
!begin_verbatim
LONG  cdecl RescanBus  (WORD       BusNo);
!end_verbatim

Der Bus soll vom Treiber erneut auf vorhanden GerÑte kontrolliert werden.

FÅr Applikationen zwei sinnvolle Anwendungen:
!begin_enumerate
!item Tool fÅr Kontrolle auf nachtrÑglich eingeschaltete GerÑte. Beispiel: 
  SCSI.CPX
!item Programm sucht nach einem bestimmten GerÑt und findet es nicht. Einmal 
  RescanBus, danach neue Suche. Beispiel: GEMAR. Wenn kein Streamer gefunden 
  wurde, wird nach einem RescanBus noch mal nach einem Streamer geschaut. 
!end_enumerate

Dadurch kînnen nachtrÑglich eingeschaltete GerÑte in die GerÑteliste
aufgenommen 
werden.
#}}}


!subnode Install
#{{{
Nur fÅr Targethandling, siehe SCSIDRV2
#}}}

!subnode Deinstall
#{{{
Nur fÅr Targethandling, siehe SCSIDRV2
#}}}

!subnode GetCmd
#{{{
Nur fÅr Targethandling, siehe SCSIDRV2
#}}}

!subnode SendData
#{{{
Nur fÅr Targethandling, siehe SCSIDRV2
#}}}

!subnode GetData
#{{{
Nur fÅr Targethandling, siehe SCSIDRV2
#}}}

!subnode SendStatus
#{{{
Nur fÅr Targethandling, siehe SCSIDRV2
#}}}

!subnode SendMsg
#{{{
Nur fÅr Targethandling, siehe SCSIDRV2
#}}}

!subnode GetMsg
#{{{
Nur fÅr Targethandling, siehe SCSIDRV2
#}}}

!subnode ReqData
#{{{
Nur fÅr Targethandling, siehe SCSIDRV2
#}}}

!node Virtuelles RAM
#{{{
Bei vorhandenem virtuellem RAM ist es dem Treiber leider nicht mîglich, 
selbsttÑtig die physikalische Adresse des zu transferierenden Speichers zu 
ermitteln (die virtuellen Treiber liefern keinerlei solche Information). Eine 
eigenstÑndige Entscheidung des Treibers, wann die Daten durch einen Puffer im 
ST-RAM zu kopieren sind, erscheint auch nicht sinnvoll, da zur Vermeidung von 
Deadlocks fÅr jeden Prozeû ein eigener Puffer eingerichtet werden mÅûte.
Daher mÅssen Programme selbsttÑtig davor sorgen, daû der zu transferierende 
Speicher im ST-RAM liegt, wenn virtuelles RAM vorliegt (siehe auch SCSILIB.H).
Der Transfer fÅr ACSI-Zugriffe Åber den FRB bzw den XFRB stellt dabei kein 
Problem da.
#}}}

!node Tips
#{{{
Wenn ein Programm den Treiber benutzt, sollte es unbedingt auf ein GerÑt ein
CheckDev absetzen. Dies ist sinnvoll, wenn der Treiber dadurch feststellen
kann, was fÅr ein Adaptertyp z.B.auf ACSI liegt.
Meine Routinen checken dabei, ob es sich um einen ALIA handelt, oder auch um
einen ICD-Adapter.
Im Falle eines ICD-Adapters ergibt sich dadurch die Mîglichkeit, daû der
Treiber fÅr Class-1-Kommandos die ICD-Technik benutzt.
#}}}

!node Treiberinstallation
#{{{
Es werden nur wesentliche Stichpunkte genannt, die von Treibern zu beachten 
sind.

Wenn bereits ein Treiber installiert ist:

!begin_itemize
!item
  Treiber dÅrfen bereits existierende Busse nicht ersetzen, es muû also 
  zunÑchst nach Bussen gescannt werden, dann kînnen die eigenen Busse auf 
  freie Bus-Ids gelegt werden.

  Die Busse 0 und 1 (als Standard-ACSI und Standard-SCSI) sollten nicht 
  umgemappt werden, da sonst von einer doppelten Meldung der Busse auszugehen 
  ist.

  Der Cookieinhalt des vorhergehenden Treibers wird dann gemerkt und die 
  eigenen Daten werden in die Struktur des alten Treibers geschrieben, die 
  Daten werden also ersetzt.

  Der Cookiewert (der Zeiger im Cookiejar) darf NICHT ersetzt werden.

!item
  Bei cInqFirst hat der Treiber das private-Feld komplett mit Nullen zu 
  fÅllen. Danach hat jeder Treiber im private.BusIds das mit der gemeldeten 
  Busnummer korrespondierende Bit zu setzen.

  Bei InquireBus dagegen kann der Treiber mit dem Feld machen, was er will, 
  da kein anderer Treiber mit diesen Parametern zu tun hat.


!item
  Der Treiber darf selbststÑndig eine Auswertung des Sensecodes durchfÅhren und 
  entsprechende Fehler absetzen (per Error auf dem handle).
  Dabei dÅrfen nur eindeutige Fehler gewertet werden (Sensecodes fÅr
  Mediachange (z.B. $28/$00) oder Reset (z.B. $29/$00)), eine Interpretation von
  Sensecodes ist nicht erlaubt (zB NOT READY als Mediachange zu interpretieren!)

  Dem Aufrufer ist dabei kein pending Error zu melden, ihm ist ganz normal der 
  Sensecode mit Status Checkcondition zu liefern.

  Dies ist durchaus sinnvoll fÅr Anwendungen, die selbst (fehlerhafterweise) 
  keine Fehlermeldung vermerken, diese mÅssen aber dennoch den normalen Fehler 
  gemeldet bekommen.

!item FÅr die zu vergebenden Busnummern gelten folgende Konventionen:
  !begin_enumerate
    !item 0 ist fÅr ACSI reserviert
    !item 1 ist fÅr Standard-SCSI reserviert (TT-SCSI/Falcon-SCSI/1. SCSI-Bus 
    in Mac/PC/Medusa/...)
    !item 2 ist auf Atari-kompatiblen fÅr IDE reserviert(!N)auf anderen 
    Rechnern gilt diese Reservierung (!U)nicht(!u).(!n)
  !end_enumerate

  Diese Verteilung gilt ausschlieûlich fÅr die Implementierung von Treibern, 
  Klienten dÅrfen daraus keine Annahmen herleiten!

!end_itemize


!begin_itemize
!item Die Fehlermeldungen, die ein Treiber zu melden hat/melden kann:

  !begin_description
    !item [NOSCSIERROR] Alles klar, kein Fehler
    !item [SELECTERROR] Das GerÑt konnte nicht selektiert werden. Bei SCSI ein 
      Timeout auf /SEL (/BSY kam nicht)
    !item [STATUSERROR] Defaultfehler, wenn gar nix geht
    !item [PHASEERROR] Eine ungÅltige Phase wurde erkannt. Diese Fehlermeldung 
      ist fÅr Busphasen vorgesehen, die nicht der SCSI-Norm entsprechen. Dies 
      sind die Phasen mit /C/D = 0, /MSG = 1 und /I/O = 0 oder = 1
    !item [BSYERROR]
      Das Target hat unkontrolliert den Bus freigegeben (busy loss)
    !item [BUSERROR] Busfehler bei der öbertragung (z.B.die Fehlermeldung des 
      TT-DMA-Chip)
    !item [TRANSERROR] Beim DMA-Transfer keine Daten Åbertragen. Nur 
      verwenden, wenn Datenphase eingeleitet, aber dann nichts Åbertragen 
      wurde, also als GerÑtefehler, nicht als SCSI-Fehler zu verstehen.
    !item [FREEERROR] Wenn der Bus nach Abschluû (Msg Complete) nicht 
      freigegeben werden konnte (Busy bleibt stehen)
    !item [TIMEOUTERROR] Ein Timeout bei der Verbindung (nicht Selektion, dort 
      SELECTERROR verwenden)
    !item [DATATOOLONG] So viele Daten kînnen nicht mit einem Transfer 
      Åbertragen werden (zB FRB-Grîûe).
    !item [LINKERROR] Bei Linked-Cmd trat Fehler auf (spezielle Meldung fÅr 
      ACSI mit Linked Cmds
    !item [TIMEOUTARBIT] Wenn innerhalb einer vom Treiber vorzusehenden Zeit 
        keine Arbitrierung um den Bus mit Erfolg beendet werden konnte.
    !item [PENDINGERROR] Soll gemeldet werden, wenn auf einem handle noch ein 
        Fehler gemerkt und nicht abgeholt ist. Der Klient muû mit 
        Error(cErrRead) den Fehler abholen, dann wird der Fehler auf diesem 
        Handle gelîscht.
    !item [PARITYERROR] es ist ein Parityfehler aufgetreten
  !end_description

!item ist kein Puffer fÅr Request Sense angegeben, darf der Treiber auch kein 
Request Sense ausfÅhren. Der Aufrufer signalisiert damit, daû er die 
Parameter im Falle eines Fehlers selbst abholen will.

!item Das private-Feld bei InquireSCSI muû vom Treiber bei
InquireFirst gelîscht werden. Das private-Feld ist als privat fÅr die
Treiber gegenÅber den Applikationen anzusehen.  Daher ist der Inhalt
des Feldes auch definiert (siehe scsidefs.h). Jeder Treiber hat die
entsprechenden Felder auszufÅllen, um den korrekten Ablauf von
InquireSCSI sicherzustellen. Nicht definierte Fehler sind reserviert
und dÅrfen vom Treiber nicht fÅr eigene Zwecke benutzt werden.

Dokumentation der feldes siehe scsi.h

!item das private-Feld bei InquireBus ist Privatsache des jeweiligen 
Treibers. Da eine Busnummer von einem Treiber verwaltet wird, ist es dem 
Treiber Åberlassen, wie er das Feld nutzt, eine Synchronisation/Abstimmung 
des Formates mit anderen Treibern ist nicht nîtig.

!end_itemize
#}}}

!node History
#{{{
PrÑzisierungen der Dokumentation/énderungen des Treibers

!begin_itemize
  !item Dokumentation 1.1

  !begin_itemize
    !item
    Ist der SenseBuffer bei In und Out NULL, so wird kein Request Sense 
    vom Treiber durchgefÅhrt (erst ab Treiberversion 1.01).

    !item
    Bei InquireSCSI ist das private-Feld von allen Treibern so zu 
    behandeln, wie es definiert ist. Eigene Daten dÅrfen dort nicht 
    untergebracht werden.
    Bei cInqFirst hat der Treiber das private-Feld komplett mit Nullen zu 
    fÅllen. Danach hat jeder Treiber in private.BusIds das mit der gemeldeten 
    Busnummer korrespondierende Bit zu setzen.

    Bei InquireBus dagegen kann der Treiber mit dem Feld machen, was er will, 
    da kein anderer Treiber mit diesen Parametern zu tun hat.

    !item Reihenfolge der ErklÑrungen geÑndert

    !item Einige weitere ErklÑrungen hinzugefÅgt

    !item Bei Open ist es angenehm, wenn der Treiber bei eigener GerÑteid ein 
    Handle liefert und wenigstens Test Unit Ready und Inquiry mit 
    Processordevice meldet.

    !item ErklÑrung, welche Daten vom Parameterblock bei In und Out 
    verÑndert werden dÅrfen.

  !end_itemize

!end_itemize
#}}}

!end_document
